;; Missionaries and Cannibals SSPS
;;Author: Justin Ross

;;Establish Trace Flag
(setf *trace-search* nil)
(setf *graphviz* t)

;;Modeling a Bank
(defclass bank()
 (
  (missionaries :accessor bank-missionaries :initarg :missionaries)
  (cannibals :accessor bank-cannibals :initarg :cannibals)
  (boat :accessor bank-boat :initarg :boat) 
 )
)

(defmethod display ((b bank))
  (format t "MISSIONARIES=~A CANNIBALS=~A BOAT=~A"
	  (bank-missionaries b) (bank-cannibals b) (bank-boat b)
   )
  (terpri)
 nil
)
(defmethod equal-bank ((b1 bank) (b2 bank))
	(and 
		(equal (bank-missionaries b1) (bank-missionaries b2))
		(equal (bank-cannibals b1) (bank-cannibals b2))
		(equal (bank-boat b1) (bank-boat b2))
   )
)

(defmethod copy-bank ((b bank))
	(make-instance 'bank 
		:missionaries (bank-missionaries b)
		:cannibals (bank-cannibals b)
		:boat (bank-boat b)
     )
)
(defmethod goal-left-bank-p ((b bank))
	(and 
		(equal (bank-missionaries b) nil)
		(equal (bank-cannibals b) nil)
		(equal (bank-boat b) nil)
	)
)

(defmethod goal-right-bank-p ((b bank))
	(and 
		(equal (bank-missionaries b) '(m m m))
		(equal (bank-cannibals b) '(c c c))
		(equal (bank-boat b) 'b)
	)
)

(defmethod boatlr ((lb bank) (rb bank))
	(setf (bank-boat lb) nil)
	(setf (bank-boat rb) 'b)
)
(defmethod boatrl ((lb bank) (rb bank))
	(setf (bank-boat lb) 'b)
	(setf (bank-boat rb) 'nil)
)
(defmethod move-missionary-lr ((lb bank) (rb bank) &aux lm rm)
	(setf lm (bank-missionaries lb))
	(pop lm)
	(setf (bank-missionaries lb) lm)
	
	(setf rm (bank-missionaries rb))
	(push 'm rm)
	(setf (bank-missionaries rb) rm)
)
(defmethod move-missionary-rl ((lb bank) (rb bank) &aux lm rm)
	(setf rm (bank-missionaries rb))
	(pop rm)
	(setf (bank-missionaries rb) rm)
	
	(setf lm (bank-missionaries lb))
	(push 'm lm)
	(setf (bank-missionaries lb) lm)
)
(defmethod move-cannibal-lr ((lb bank) (rb bank) &aux lc rc)
	(setf lc (bank-cannibals lb))
	(pop lc)
	(setf (bank-cannibals lb) lc)
	
	(setf rc (bank-cannibals rb))
	(push 'c rc)
	(setf (bank-cannibals rb) rc)
)
(defmethod move-cannibal-rl ((lb bank) (rb bank) &aux lc rc)
	(setf rc (bank-cannibals rb))
	(pop rc)
	(setf (bank-cannibals rb) rc)
	
	(setf lc (bank-cannibals lb))
	(push 'c lc)
	(setf (bank-cannibals lb) lc)
)
(defmethod mlr ((lb bank) (rb bank))
	(move-missionary-lr  lb rb)
	(boatlr lb rb)
)
(defmethod mrl ((lb bank) (rb bank))
	(move-missionary-rl lb rb)
	(boatrl lb rb)
)
(defmethod clr ((lb bank) (rb bank))
	(move-cannibal-lr lb rb)
	(boatlr lb rb)
)
(defmethod crl((lb bank) (rb bank))
	(move-cannibal-rl lb rb)
	(boatrl lb rb)
)
(defmethod mmlr ((lb bank) (rb bank))
	(move-missionary-lr lb rb)
	(move-missionary-lr lb rb)
	(boatlr lb rb)
)
(defmethod mmrl ((lb bank) (rb bank))
	(move-missionary-rl lb rb)
	(move-missionary-rl lb rb)
	(boatrl lb rb)
)
(defmethod cclr ((lb bank) (rb bank))
	(move-cannibal-lr lb rb)
	(move-cannibal-lr lb rb)
	(boatlr lb rb)
)
(defmethod ccrl ((lb bank) (rb bank))
	(move-cannibal-rl lb rb)
	(move-cannibal-rl lb rb)
	(boatrl lb rb)
)
(defmethod mclr ((lb bank) (rb bank))
	(move-missionary-lr lb rb)
	(move-cannibal-lr lb rb)
	(boatlr lb rb)
)
(defmethod mcrl ((lb bank) (rb bank))
	(move-missionary-rl lb rb)
	(move-cannibal-rl lb rb)
	(boatrl lb rb)
)

;;Modeling a State
(defclass state()
  (
   (left-bank :accessor state-left-bank :initarg :left-bank)
   (right-bank :accessor state-right-bank :initarg :right-bank)
   )
  )

(defmethod display ( (s state) )
  (princ "LEFT: ")
  (display (state-left-bank s) )
  (princ "RIGHT: ")
  (display (state-right-bank s) )
  nil
  )

(defmethod equal-state-p ((s1 state) (s2 state))
  (and
    (equal-bank (state-left-bank s1) (state-left-bank s2))
	(equal-bank (state-right-bank s1) (state-right-bank s2))
	)
 )
 
(defmethod copy-state ((s state))
  (make-instance 'state 
         :left-bank (copy-bank (state-left-bank s))
         :right-bank (copy-bank (state-right-bank s)))
)
(defmethod goalp ((s state))
	(and 
		(goal-left-bank-p (state-left-bank s))
		(goal-right-bank-p (state-right-bank s))
	)
)
(defmethod feast-state-p ((s state) &aux lb rb)
	(setf lb (state-left-bank s))
	(setf rb (state-right-bank s))
	(or
		(and
			(> (length (bank-cannibals lb)) (length (bank-missionaries lb)))
			(> (length (bank-missionaries lb)) 0)
		)
		(and
			(> (length (bank-cannibals rb)) (length (bank-missionaries rb)))
			(> (length (bank-missionaries rb)) 0)
		)
	)
)

;;Modeling a Node
(defclass node()
	(
		(name :accessor node-name :initarg :name)
		(state :accessor node-state :initarg :state)
		(parent :accessor node-parent :initarg :parent)
		(operator :accessor node-operator :initarg :operator)
	)
)
(defmethod display ((n node))
	(princ (node-name n))
	(if (not (rootp n) )
		(let ()
			(princ " ")
			(princ (node-name (node-parent n)))
			(princ " ")
			(display (node-operator n) )
		)
    )
	(terpri)
	(display (node-state n))
	nil
)
(defun display-explored-nodes ()
	(write-line "EXPLORED")
	(mapcar #'display *explored*)
	(terpri)
	nil
)
(defun display-unexplored-nodes ()
	(write-line "UNEXPLORED")
	(mapcar #'display *unexplored*)
	(terpri)
	nil
)
(defmethod display-enode ((e-node node))
	(write-line "E-NODE")
	(display e-node)
	(terpri)
	nil
)
(defmethod display-solution((n node))
	(cond
		((rootp n)
			(terpri)
		)
		(t
			(display-solution (node-parent n))
			(princ (operator-description (node-operator n)))
			(terpri)
		)
   )
  nil
)
(defmethod rootp ((n node))
	(eq (node-name n) 'root)
)
(defmethod goalp ((n node))
	(goalp (node-state n))
)
(defmethod feast-state-p ((n node))
	(feast-state-p (node-state n))
)
(defmethod exploredp ((e-node node) &aux states)
	(setf states (mapcar #'node-state *explored*))
	(member (node-state e-node) states :test #'equal-state-p)
)

;; Modeling an Operator
(defclass operator()
	(
		(name :accessor  operator-name :initarg :name)
		(precondition :accessor operator-precondition :initarg :precondition)
		(description :accessor operator-description :initarg :description)
	)
)
(defmethod display ((o operator))
	(format t "MOVE-~A" (operator-name o))
)
(defun establish-operators ()
	(setf *mlr* (make-instance 'operator :name 'mlr
			    :precondition "Left bank has atleast (M B)"
			    :description "Move one Missionary from left to right bank")
	)
	(setf *clr* (make-instance 'operator :name 'clr
			    :precondition "Left bank has atleast (C B)"
			    :description "Move one Cannibal from left to right bank")
	)
	(setf *mrl* (make-instance 'operator :name 'mrl
			    :precondition "Right bank has atleast (M B)"
			    :description "Move one Missionary from right to left bank")
	)
	(setf *crl* (make-instance 'operator :name 'crl
			    :precondition "Right bank has atleast (C B)"
			    :description "Move one Cannibal from right to left bank")
	)
	(setf *mmlr* (make-instance 'operator :name 'mmlr
			    :precondition "Left bank has atleast (M M B)"
			    :description "Move two Missionaries from left to right bank")
	)
	(setf *cclr* (make-instance 'operator :name 'cclr
			    :precondition "Left bank has atleast (C C B)"
			    :description "Move two Cannibals from left to right bank")
	)
	(setf *mmrl* (make-instance 'operator :name 'mmrl
			    :precondition "Right bank has atleast (M M B)"
			    :description "Move two Missionarie from right to left bank")
	)
	(setf *ccrl* (make-instance 'operator :name 'ccrl
			    :precondition "Right bank has atleast (C C B)"
			    :description "Move two Cannibals from right to left bank")
	)
	(setf *mclr* (make-instance 'operator :name 'mclr
			    :precondition "Left bank has atleast (M C B)"
			    :description "Move a Missionary and a Cannibal from left to right bank")
	)
	(setf *mcrl* (make-instance 'operator :name 'mcrl
			    :precondition "Right bank has atleast (M C B)"
			    :description "Move a Missionary and a Cannibal from right to left bank")
	)
	(setf *operator-list* (list *mlr* *mrl* *clr* *crl* *mmlr* *mmrl* *cclr* *ccrl* *mclr* *mcrl*) )
	nil
)
(defmethod apply-operator ((o operator) (s state) &aux lb rb)
	(setf lb (state-left-bank s))
	(setf rb (state-right-bank s))
	(cond
		((eq (operator-name o) 'mlr)
			(mlr lb rb)
		)
		((eq (operator-name o) 'mrl)
			(mrl lb rb)
		)
		((eq (operator-name o) 'clr)
			(clr lb rb)
		)
		((eq (operator-name o) 'crl)
			(crl lb rb)
		)
		((eq (operator-name o) 'mmlr)
			(mmlr lb rb)
		)
		((eq (operator-name o) 'mmrl)
			(mmrl lb rb)
		)
		((eq (operator-name o) 'cclr)
			(cclr lb rb)
		)
		((eq (operator-name o) 'ccrl)
			(ccrl lb rb)
		)
		((eq (operator-name o) 'mclr)
			(mclr lb rb)
		)
		((eq (operator-name o) 'mcrl)
			(mcrl lb rb)
		)
	)
	nil
)
(defmethod applicable-mlr ((s state))
	(and
		(eq (bank-boat (state-left-bank s)) 'b)
		(>= (length (bank-missionaries (state-left-bank s))) 1)
	)
)
(defmethod applicable-mrl ((s state))
	(and 
		(eq (bank-boat (state-right-bank s)) 'b)
		(>= (length (bank-missionaries (state-right-bank s))) 1)
	)
)
(defmethod applicable-clr ((s state))
	(and 
		(eq (bank-boat (state-left-bank s)) 'b)
		(>= (length (bank-cannibals (state-left-bank s))) 1)
	)
)
(defmethod applicable-crl ((s state))
	(and
		(eq (bank-boat (state-right-bank s)) 'b)
		(>= (length (bank-cannibals (state-right-bank s))) 1)
	)
)
(defmethod applicable-mmlr ((s state))
	(and 
		(eq (bank-boat (state-left-bank s)) 'b)
		(>= (length (bank-missionaries (state-left-bank s))) 2)
	)
)
(defmethod applicable-mmrl ((s state))
	(and
		(eq (bank-boat (state-right-bank s)) 'b)
		(>= (length (bank-missionaries (state-right-bank s))) 2)
	)
)
(defmethod applicable-cclr ((s state))
	(and 
		(eq (bank-boat (state-left-bank s)) 'b)
		(>= (length (bank-cannibals (state-left-bank s))) 2)
	)
)
(defmethod applicable-ccrl ((s state))
	(and 
		(eq (bank-boat (state-right-bank s)) 'b)
		(>= (length (bank-cannibals (state-right-bank s))) 2)
	)
)
(defmethod applicable-mclr ((s state))
	(and
		(eq (bank-boat (state-left-bank s)) 'b)
		(>= (length (bank-missionaries (state-left-bank s))) 1)
		(>= (length (bank-cannibals (state-left-bank s))) 1)
	)
)
(defmethod applicable-mcrl ((s state))
	(and 
		(eq (bank-boat (state-right-bank s)) 'b)
		(>= (length (bank-missionaries (state-right-bank s))) 1)
		(>= (length (bank-cannibals (state-right-bank s))) 1)
	)
)
(defmethod applicablep ((o operator) (s state))
	(cond
		((eq (operator-name o) 'mlr)
			(applicable-mlr s)
		)
		((eq (operator-name o) 'mrl)
			(applicable-mrl s)
		)
		((eq (operator-name o) 'clr)
			(applicable-clr s)
		)
		((eq (operator-name o) 'crl)
			(applicable-crl s)
		)
		((eq (operator-name o) 'mmlr)
			(applicable-mmlr s)
		)
		((eq (operator-name o) 'mmrl)
			(applicable-mmrl s)
		)
		((eq (operator-name o) 'cclr)
			(applicable-cclr s)
		)
		((eq (operator-name o) 'ccrl)
			(applicable-ccrl s)
		)
		((eq (operator-name o) 'mclr)
			(applicable-mclr s)
		)
		((eq (operator-name o) 'mcrl)
			(applicable-mcrl s)
		)
	)
)

;;Modeling a Name-Generator
(defclass name-generator()
	(
		(prefix :accessor name-generator-prefix :initarg :prefix :initform "name")
		(nr :accessor name-generator-nr :initform 0)
	)
)
(defmethod next ((ng name-generator))
	(setf (name-generator-nr ng) (+ 1 (name-generator-nr ng)))
	(concatenate 'string
		(name-generator-prefix ng)
		(write-to-string (name-generator-nr ng))
	)
)

;;Generating Children
(defmethod children-of ((e-node node) &aux kids)
	(if (applicablep *mlr* (node-state e-node))
		(push (child-of e-node *mlr*) kids)
	)
	(if (applicablep *mrl*(node-state e-node))
		(push (child-of e-node *mrl*) kids)
	)
	(if (applicablep *clr* (node-state e-node))
		(push (child-of e-node *clr*) kids)
	)
	(if (applicablep *crl*(node-state e-node))
		(push (child-of e-node *crl*) kids)
	)
	(if (applicablep *mmlr* (node-state e-node))
		(push (child-of e-node *mmlr*) kids)
    )
	(if (applicablep *mmrl*(node-state e-node))
		(push (child-of e-node *mmrl*) kids)
	)
	(if (applicablep *cclr* (node-state e-node))
		(push (child-of e-node *cclr*) kids)
	)
	(if (applicablep *ccrl*(node-state e-node))
      (push (child-of e-node *ccrl*) kids)
	)
	(if (applicablep *mclr* (node-state e-node))
		(push (child-of e-node *mclr*) kids)
    )
	(if (applicablep *mcrl*(node-state e-node))
      (push (child-of e-node *mcrl*) kids)
	)
	kids
)
(defmethod child-of ((n node) (o operator) &aux new-node c)
	(setf new-node (make-instance 'node))
	(setf (node-parent new-node) n)
	(setf (node-operator new-node) o)
	(setf (node-name new-node) (next *ng*)) 
	(setf c (copy-state (node-state n)))
	(apply-operator o c)
	(setf (node-state new-node) c)
	new-node
)

;;Setup
(defmethod setup(&aux root lb rb istate)
	(setf lb (make-instance 'bank :missionaries '(m m m)
						:cannibals '(c c c)
						:boat 'b))
	(setf rb (make-instance 'bank :missionaries '()
						:cannibals '()
						:boat nil))
	(setf istate (make-instance 'state :left-bank lb :right-bank rb))
	(setf root (make-instance 'node :state istate :name 'root ))
	(setf *unexplored* (list root))
	(setf *explored* () )
	(setf *ng*(make-instance 'name-generator :prefix "N"))
	nil
)

;;Breadth-First Search Solve
(defmethod solve (&aux kids e-node)
	(if *trace-search*
		(let ()
			(terpri)(write-line ">>> Solve")(terpri)
			(display-explored-nodes)
			(display-unexplored-nodes)
		)
	)
	(cond
		((null *unexplored*)
			(write-line "There is no solution")
			(return-from solve nil)
		)
	)
	(setf e-node (pop *unexplored*))
	(if *trace-search*
		(display-enode e-node)	
	)
	(if *graphviz*
          (display-graphviz e-node)
	)
	(cond
		((goalp  e-node)
			;(write-line "Got a solution!")
			;(display-solution e-node)
		)
		((feast-state-p e-node)
			(solve)
		)
		((exploredp e-node)
			(solve)
		)
		(t
			(push e-node *explored*)
			(setf kids (children-of e-node))
			(setf *unexplored* (append *unexplored* kids))
			(solve)
		)
	)
	nil
)

;;Main
(defmethod mc()
	(establish-operators)
	(setup)
	(when *graphviz*
    (format t "digraph mc {~%")
    (format t "  size=\"10,10\"~%")
    (format t "  rankdir=TB;~%")
    (format t "  node [style=filled];~%~%"))
	(solve)
	(when *graphviz*
    (format t "}~%"))
)
(defmethod display-graphviz ((n node))
  (format t "  \"~A\" [ label=<"
          (node-name n))
  (display-graphviz (node-state n))
  (format t ">, color=\"~A\" ];~%"
          (node-color n))
  (display-graphviz-edge n))
 
(defmethod display-graphviz-edge ((n node))
  (when (not (rootp n))
    (format t "  \"~A\" -> \"~A\" [ label=\"~A\" ];~%"
            (node-name (node-parent n))
            (node-name n)
            (operator-name (node-operator n))))
  (format t "~%"))

(defmethod node-color ((n node))
  (cond
    ((goalp (node-state n))
     "royalblue")

    ((feast-state-p (node-state n))
     "red")

    (:else
     "beige"))) 
  
(defmethod display-graphviz ((s state))
  (format t "L = ")
  (display-graphviz (state-left-bank  s))
  (format t "<BR/>")
  (format t "R = ")
  (display-graphviz (state-right-bank s)))
  
  (defmethod display-graphviz ((b bank))
  (format t "M:~D, C:~D, B:~A"
          (length (bank-missionaries b))
          (length (bank-cannibals    b))
          (if (bank-boat b)
            "B"
            0)))
