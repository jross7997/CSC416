;;Travling Salesman Problem GA
;;File: tsp.l
;;Author: Justin Ross
;; With 11 cities randomly selected using "https://www.randomlists.com/random-us-cities"
;;All of the distances are 1/10th of an approximation made in miles. Measurements are
;;from "https://www.distancefromto.net/"

;;Imports
(load "lp.l")

;;Constants
;;A Austin, Texas
;;B Scottsdale, Arizona
;;C Dallas, Texas
;;D Cincinnati, Ohio
;;E Lubbock, Texas
;;F Boston, Massachusetts
;;G Indianapolis, Indiana
;;H Denver, Colorado
;;I Milwaukee, Wisconsin
;;J Hialeah, Florida
;;K Rochester, New York
(setf *cities* '(A B C D E F G H I J K))
(setf (symbol-plist 'A) '(name "Austin,Texas" B 86 C 18 D 98 E 33 F 170 G 93 H 77 I 104 J 111 K 142))
(setf (symbol-plist 'B) '(name "Scottsdale,Arizona" A 86 C 88 D 157 E 58 F 229 G 149 H 58 I 145 J 197 K 196))
(setf (symbol-plist 'C) '(name "Dallas,Texas" A 18 B 88 D 81 E 23 F 155 G 76 H 66 I 86 J 110 K 126))
(setf (symbol-plist 'D) '(name "Cincinnati,Ohio" A 98 B 157 C 81 E 104 F 74 G 10 H 109 I 32 J 95 K 46))
(setf (symbol-plist 'E) '(name "Lubbock,Texas" A 33 B 58 C 23 D 104 F 177 G 97 H 46 I 100 J 140 K 147))
(setf (symbol-plist 'F) '(name "Boston Massachusetts" A 170 B 229 C 155 D 74 E 177 G 80 H 177 I 85 J 126 K 34))
(setf (symbol-plist 'G) '(name "Indianapolis,Indiana" A 93 B 149 C 76 D 10 E 97 F 80 H 100 I 24 J 102 K 50))
(setf (symbol-plist 'H) '(name "Denver,Colorado" A 77 B 58 C 66 D 109 E 46 F 177 G 100 I 91 J 172 K 143))
(setf (symbol-plist 'I) '(name "Milwaukee,Wisconsin" A 104 B 145 C 86 D 32 E 100 F 85 G 24 H 91 J 126 K 52))
(setf (symbol-plist 'J) '(name "Hialeah,Florida" A 111 B 197 C 110 D 95 E 140 F 126 G 102 H 172 I 126 K 121))
(setf (symbol-plist 'K) '(name "Rochester,New York" A 142 B 196 C 126 D 46 E 147 F 34 G 50 H 143 I 52 J 121))
;;Task 1: Strings
(defun tsp-string-builder((lst list) &aux ele rem)
  (cond
   ((null lst) nil)
   (t
    (setf ele (pick lst))
    (setf rem (remove ele lst :count 1))
    (snoc ele (tsp-string-builder rem))
   )
  )
)
(defun tsp-string()
  (tsp-string-builder *cities*)
)

;;Task 2: Mutation
(defun swap((lst list) (i integer) (j integer) &aux item1 item2)
  (setf item1 (nth i lst))
  (setf item2 (nth j lst))
  (setf (nth i lst) item2)
  (setf (nth j lst) item1)
  lst
)  
(defun mutation((tsp-str list)&aux p q)
  (setf p (random (length tsp-str)))
  (setf q (random (length tsp-str)))
  (swap tsp-str p q)
)

;;Task 3: Crossover
(defmethod equal-set-p ((lst1 list) (lst2 list) &aux flag temp1 temp2 atm)
  (setf flag nil)
  (setf temp1 lst1)
  (setf temp2 lst2)
  (dotimes (x (length lst2))
    (setf atm (car temp1))
    (setf temp1 (take-from atm temp1))
    (setf temp2 (take-from atm temp2))
  )
  (if (and (null temp1) (null temp2))
      (setf flag 't)
  )
  flag
)
(defun common-span-n ((m list) (f list) (n integer) &aux lst1 lst2 child)
  (block block
	 (dotimes (i (length m))
	   (if (>= (- (length m) 1) (+ n i))
	       (let ()
		 (dotimes(j (length f))
		   (if (>= (- (length m) 1) (+ n j))
		       (let ()
			 (setf lst1 (subseq m i (+ n i)))
			 (setf lst2 (subseq f j (+ n j)))
			; (format t "Mother: ~A~%" lst1)
			; (format t "Father: ~A~%" lst2)
			 (if (equal-set-p lst1 lst2)
			     (let ()
			       (setf child (append (first-n m i) lst2 (rest-n m (+ n i))))
			     ;  (format t "Child: ~A~%" child)
			       (return-from block)
			     )
			 )
		       )
		   )
		 )
	      )
	   )
	)		   
     t)
  child
)  
(defun common-span ((m list) (f list) &aux half)
  (setf half (round (/ (length m) 2)))
  (common-span-n m f half)
)
(defmethod first-n ((m list) (p integer))
  (subseq m 0 p)
)
(defmethod rest-n ((m list) (p integer))
  (subseq m p)
)
(defun crossover-n ((m list) (f list) (n integer))
  (common-span-n m f n)
)
(defmethod crossover ((m list) (f list))
  (find-largest-span m f)
  )
;;Task 4: Demos for Mutation and Crossover
(defmethod mutation-demo (&aux s m)
  (setf s (tsp-string))
  (dotimes (i 10)
    (format t "Test ~A~%" i)
    (format t "s = ~A~%" s)
    (format t "m = ~A~%" (mutation s))
  )
)
(defun find-largest-span ((m list) (f list) &aux child)
  (block block
	 (loop for i from (length m) downto 1 do
	       (if ( > i 0)
		   (let ()
		     (setf child (crossover-n m f i))
		     (if (not (null child))
			 (return-from block)
		     )
		   )
	        )
	   )
   t)
  child
)
(defmethod crossover-demo (&aux m f x)
  (dotimes (i 10)
    (format t "Tst ~A~%" i)
    (setf m (tsp-string))
    (setf f (tsp-string))
    (format t "m = ~A~%" m)
    (format t "x = ~A~%" (find-largest-span m f))
    (format t "f = ~A~%" f)
  )
)
    
;;Task 5: Fitness Metric
(defmethod fitness ((lst list))
  (cond
   ((null (second lst))
    0
   )
   (t
    (+ (get (first lst) (second lst))(fitness (cdr lst)))
   )
  )
)
(defun fitness-demo (&aux x )
  (dotimes (i 10)
    (format t "Trial ~A~%" i)
    (setf x (tsp-string))
    (format t "x = ~A~%" x)
    (format t "Fitness = ~A~%" (fitness x))
    )
)

;;Task 6: The Individual Class
(defclass individual ()
  (
   (tsp-string :accessor individual-tsp-string :initarg :tsp-string)
   (fitness :accessor individual-fitness :initarg :fitness)
   (number :accessor individual-number :initarg :number)
  )
)
(defmethod random-individual (&aux tsp)
  (setf tsp (tsp-string))
  (make-instance 'individual
		 :tsp-string tsp
		 :fitness (fitness tsp)
		 :number 0
  )
)
(defmethod new-individual ((nr number)(notes list))
  (make-instance 'individual
		 :tsp-string notes
		 :fitness (fitness notes)
		 :number nr
  )
)
(defmethod display ((i individual))
  (display-nnl i)(terpri)
)

(defmethod display-nnl ((i individual))
  (prin1 (individual-number i))
  (princ (filler (individual-number i)))
  (prin1 (individual-tsp-string i))
  (princ "    ")
  (prin1 (individual-fitness i))
  (princ (filler (individual-fitness i)))
)

(defmethod filler (( n number ))
  (cond
   ((< n 10) "       ")
   ((< n 100) "      ")
   ((< n 1000) "     ")
   ((< n 10000) "    ")
   ((< n 100000) "   ")
  )
)

(defmethod fitness ((i individual))
  (fitness (individual-tsp-string i))
)   
(defmethod individual-demo (&aux i0 i1 i2 i3 one two three)
  (setf i0 (random-individual))
  (display i0)
  (setf one (tsp-string))
  (setf i1 (new-individual 1 one))
  (display i1)
  (setf two (tsp-string))
  (setf i2 (new-individual 2 two))
  (display i2)
  (setf three (tsp-string))
  (setf i3 (new-individual 3 three))
  (display i3)
  (format t "Fitness of i0 = ~A~%" (fitness i0))
  (format t "Fitness of i1 = ~A~%" (fitness i1))
  (format t "Fitness of i2 = ~A~%" (fitness i2))
  (format t "Fitness of i3 = ~A~%" (fitness i3))
  nil
)
;;Task 7: The Population Class
(defconstant *population-size* 100)
(defconstant *selection-size* 8)

(defclass population()
  (
   (individuals :accessor population-individuals :initarg :individuals)
   (generation :accessor population-generation :initform 0)
   )
)
(defmethod size ((p population))
  (length (population-individuals p))
)
(defmethod display ((p population))
  (terpri)(terpri)
  (princ "Generation")
  (prin1 (population-generation p))
  (princ " population ...")
  (terpri)(terpri)
  (dolist (i (population-individuals p))
    (display i)
  )
  (terpri)
)
(defmethod initial-population (&aux individuals)
  (setf individuals ())
  (dotimes (i *population-size*)
    (push (new-individual ( + i 1)(tsp-string)) individuals)
   )
  (make-instance 'population :individuals (reverse individuals))
)
(defmethod average ((p population) &aux (sum 0))
  (dolist (i (population-individuals p))
    (setf sum (+ sum (fitness i)))
  )
  (float (/ sum (size p)))
)

(setf *select-demo* nil)

(defmethod select-individual ((p population) &aux i candidates rn)
  (setf candidates (select-individuals p))
  (setf mfi (most-fit-individual candidates))
  (if *select-demo* (select-demo-helper candidates mfi))
  mfi
)
(defmethod select-individuals ((p population) &aux individuals candidates rn)
  (setf individuals (population-individuals p))
  (setf candidates () )
  (dotimes (i *selection-size*)
    (setf rn (random (- *population-size* 1)))
    (push (nth rn individuals)candidates)
  )
  candidates
)  
(defmethod most-fit-individual ((l list) &aux max-value max-individual)
  (setf max-value 100000)
  (setf max-individual ())
  (dolist (i l)
    (if (< (fitness i) max-value)
	(let ()
	  (setf max-value (fitness i))
	  (setf max-individual i)
	  )
      )
    )
  max-individual
)
(defmethod select-demo-helper (( l list) (i individual))
  (princ "the sample of individuals ...") (terpri)
  (mapcar #'display l)
  (terpri)
  (princ "the most fit of the sample ...") (terpri)
  (display i)
  (terpri)
  nil
)
(defmethod population-demo (&aux p)
  (setf p (initial-population))
  (display p)
  (format t "Average Fitness ~A~%~%" (average p))
  (setf *select-demo* t)
  (format t "Sampling... ~%~%")
  (select-individual p) (terpri)
  (format t "Sampling...~%~%")
  (select-individual p) (terpri)
  (format t "Sampling...~%~%")
  (select-individual p) (terpri)
)
;;Task 8: Incorporating Mutation
(defmethod mutate ((i individual) &aux mutation)
  (setf mutation (mutation (individual-tsp-string i)))
  (make-instance 'individual
		 :number (individual-number i)
		 :tsp-string mutation
		 :fitness (fitness mutation)
  )
)

(defconstant *pc-m* 50)

(defmethod maybe-mutate ((i individual))
  (if(<= (+ 1 (random 100)) *pc-m*)
      (mutate i)
    i
   )
)

(defmethod mutate-demo (&aux i)
  (setf i (random-individual))
  (display i)
  (dotimes (x 20)
    (setf i (mutate i))
    (display i)
  )
)
(defmethod maybe-mutate-demo (&aux i n)
  (setf i (random-individual))
  (display i)
  (dotimes (x 20)
    (setf n (maybe-mutate i))
    (display-nnl n)
    (if (not (equal n i)) (princ " *"))
    (terpri)
    (setf i n)
  )
)
;;Task 9: Copy!
(setf *copy-demo* nil)
(defconstant *pc-c* 40)
(defmethod perform-copies ((cp population)(np population))
  (dotimes (i (nr-copies))
    (perform-one-copy cp np)
  )
)

(defmethod nr-copies ()
  (* ( / *pc-c* 100) *population-size* )
)

(defmethod perform-one-copy ((cp population)(np population)
			     &aux x m mm new-i)
  (setf m (select-individual cp))
  (if *copy-demo* (format t "Selected individual = ~%"))
  (if *copy-demo* (display m))
  (setf mm(maybe-mutate m))
  (if *copy-demo* (format t "Possibly muted individual = ~&"))
  (if *copy-demo* (display mm))
  (setf (individual-number mm) (+ 1 (size np)))
  (if *copy-demo* (format t "Renumbered individual = ~&"))
  (if *copy-demo* (display mm))
  (setf new-i (new-individual ( + 1 (size np))(individual-tsp-string mm)))
  (setf
   (population-individuals np)
   (append (population-individuals np)(list new-i))
   )
  nil
)

(defmethod empty-population ((cp population) &aux np)
  (setf np (make-instance 'population))
  (setf (population-individuals np)())
  (setf (population-generation np)(+ 1 (population-generation cp)))
  np
)

(defmethod perform-copies-demo (&aux cp np)
  (setf cp (initial-population ))
  (setf np (empty-population cp))
  (terpri)(display np)(terpri)(terpri)
  (setf *select-demo* t)
  (setf *copy-demo* t)
  (dotimes (i 10)
    (perform-one-copy cp np)
    (terpri)(display np)(terpri)(terpri)
  )
  (setf *select-demo* nil)
  (setf *copy-demo* nil)
  nil
)
;;Task 10: Crossover!
(setf *crossover-demo* nil)
(defconstant *pc-x* 60)

(defmethod perform-crossovers ((cp population) (np population))
  (dotimes (i (nr-crossovers))
    (perform-one-crossover cp np)
   )
)
(defmethod nr-crossovers ()
	(* (/ *pc-x* 100) *population-size*)
)

(defmethod perform-one-crossover ((cp population) (np population))
  (let (x m mm mother father new-i)
    (setf mother (select-individual cp))
    (setf father (select-individual cp))
    (if *crossover-demo* (format t "Selected mother = ~%"))
    (if *crossover-demo* (display mother))
    (if *crossover-demo* (format t "Selected father = ~&"))
    (if *crossover-demo* (display father))
    (setf m (crossover mother father))
    (if *crossover-demo* (format t "The crossover = ~&"))
    (if *crossover-demo* (display m))
    (setf mm (maybe-mutate m))
    (if *crossover-demo* (format t "The possibly mutated individual = ~&"))
    (if *crossover-demo* (display mm))
    (setf (individual-number mm) (+ 1 (size np)))
    (if *crossover-demo* (format t "The renumbered individual = ~&"))
    (if *crossover-demo* (display mm))
    (setf new-i (new-individual (+ 1 (size np)) (individual-tsp-string mm)))
    (setf (population-individuals np) (append (population-individuals np) (list new-i)))
  )
)

(defmethod crossover ((mother individual) (father individual) &aux mi fi x i)
  (setf mi (individual-tsp-string mother))
  (setf fi (individual-tsp-string father))
  (setf x (crossover mi fi))
  (setf i (new-individual 0 x))
  i
)

(defmethod perform-crossovers-demo (&aux cp np)
  (setf cp (initial-population))
  (setf np (empty-population cp))
  (terpri) (display np) (terpri) (terpri)
  (setf *select-demo* t)
  (setf *crossover-demo* t)
  (dotimes (i 10)
    (perform-one-crossover cp np)
    (terpri) (display np) (terpri) (terpri)
  )
  (setf *select-demo* NIL)
  (setf *crossover-demo* NIL) 
)

;;Task 11: The GA
;;THE NEXT GENERATION METHOD FOR THE GA
(defconstant *nr-generations* 25)

(defmethod next-generation ((cp population) &aux np)
  (setf np (empty-population cp))
  (perform-copies cp np)
  (perform-crossovers cp np)
  np
)

;;THE GA
;;OUTPUT IS JUST ALOT OF TEXT
(defmethod ga-text-demo (&aux p)
  (setf p (initial-population))
  (terpri)
  (summarize p)
  (dotimes (i *nr-generations*)
    (setf p (next-generation p))
    (check-average p)
  )
  (terpri)
  (summarize p)
  (show-best-route (select-individual p))
)
;;METHODS TO PROVIDE PROGRESS INFO
(defmethod summarize ((p population))
  (display p)
  (check-average p)
  (average p)
)

(defmethod check-average ((p population))
  (format t "average fitness of population ~A = ~A~%" 
			(population-generation p) (average p))
)
(defmethod show-best-route((i individual)&aux length lst names city)
  (display i)
  (get-name-list i)
  nil
)
(defmethod get-name-list ((i individual)&aux city-list names)
  (setf city-list (individual-tsp-string i))
  (format t "The best fit route: ~%")
  (dotimes (x (length city-list))
    (format t "~A~%" (get (nth x city-list) 'name))
  )
)

  
